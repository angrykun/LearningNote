## 第十一章 泛型 ##

### 11.1 泛型是什么 ###

泛型代表的就是”通用类型“，它可以代替任意的数据类型，是类型参数化，从而达到只要实现一个方法就可以操作多种数据类型的目的。**泛型将方法实现行为与方法操作的数据类型分离**，实现了代码重用。


    //用int作为实际参数来初始化泛型类型
    List<int> intList = new List<int>();
    intList.Add(3);

    //用string作为实际参数来初始化泛型类型
    List<string> stringList = new List<string>();
    stringList.Add("learning");


### 11.2 C#2.0 为什么引入泛型 ###

如果不引入泛型，会带来怎么样的不便呢？
写出比较两个整数大小的方法：


    public class Compare
    {
        public static int compareInt(int int1, int int2)
        {
            //比较两个整数大小的方法，方法返回比较大的数
            if (int1.CompareTo(int2) > 0)
            {
                return int1;
            }
            else
            {
                return int2;
            }
        }
    }

上述代码对int类型数据是没有问题的，但是当客户需要实现可以比较两个字符串的大小，这是你就不得不在类中新增一个实现字符串比较大大小的方法。


    public static string compareString(string str1, string str2)
    {
        if (str1.CompareTo(str2) > 0)
        {
            return str1;
        }
        else
        {
            return str2;
        }
    }


当用户需要新增浮点数比较大小的方法，我们必须频繁的增加代码，而且方法的大部分代码都是非常相似的。因此我们希望，如果只定义一个比较的方法就能比较所有不同类型的大小，那该多好。

在泛型出现之前，这是无法实现的。微软在C#2.0中提出**泛型**，使得类型可以被参数化。


    //Compare<T>为泛型类，T 为类型参数
    public class Compare<T> where T : IComparable
    {
        //使用泛型实现的比较方法
        public static T compareGeneric(T t1, T t2)
        {
            if (t1.CompareTo(t2) > 0)
            {
                return t1;
            }
            else
            {
                return t2;
            }
        }
    }

泛型除了可以实现**代码重用外**，还提供了**更好的性能和类型安全特性**。

类型转换过程中存在拆箱和装箱，这个过程会银锭的性能损失。泛型可以避免性能损失的有效方法。