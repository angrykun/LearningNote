# 第四章 C#中的类 #

----------

## 4.1 什么是类 ##
	C#中，类代表一组具有公共属性和行为的对象。

## 4.2 C#中如何定义一个类 ##
     使用class关键字，即可定义一个类。
    	class Person
    	{
    		//类成员定义
    	} 
    默认情况下，如果class关键字没有显示支出访问修饰符，则类的访问修饰符为 internal，表示尽在当前项目内可访问。

##访问权限表

- 无或internal	->	只能在同一个程序集中访问类
- public	->	同一程序集或引用该程序集的其他程序集都可以访问类
- abstract或internal abstract -> 只能在同一个程序集中访问类，该类不能被实例化，只能被继承  
- public abstract	->	 同一程序集或引用该程序集都可以访问类，该类不能被实例化，只能被继承
- sealed或internal sealed	->	同一程序集中访问类，该类不能被继承，只能被实例化
- public sealed	->	同一程序集或引用该程序集的其他程序集都可以访问该类，不能被机场，只能被实例化

## 4.3 类的成员 ##
	类的成员包括字段，属性，方法和构造函数等。它们与类一样，也有自己的访问权限。静态成员属于类级别。
- public	同一程序集或引用该程序集的其他程序集都可以访问
- private	当前类内部可以访问
- protected	当前类内部或者继承该类的子类
- internal	同一程序集中可以访问
-protected internal	同一程序集，该类和派生类中可以访问

## 4.3.1 字段 ##
关键字`readonly`表示该字段是只读的，不需要在定义时进行初始化，可以在构造函数中完成初始化；`const`表示该字段是不可改变的，在定义时，必须对该字段进行初始化，否则会产生编译错误。
静态字段和实例字段的区别：静态字段必须通过类进行访问，而实例字段则需要通过类的对象实例进行访问。

## 4.3.2 属性 ##

属性是对字段的扩展，根据面向对象封装思想，字段最好设为private，这样可以防止客户端直接对字段进行篡改。

属性定义主要由get访问器和set访问器组成，get访问器负责对字段进行读取，set访问器负责为字段进行赋值(它通过value隐式参数来表示用户传入值)。get访问器和set访问器可以理解为两个方法。在不使用属性的情况下，只能通过定义两个方法来对字段进行访问，C#属性，简化了这种操作。

## 4.3.3 方法 ##
方法是有方法签名和一系列语句块组成。

方法重载指的是在勒种可以定义多个相同名称但方法签名不同的方法，**方法签名不同指的是参数顺序，参数类型，参数个数不同，方法返回类型不属于方法签名的一部分。**

 	public class Person
    {
        //打印方法
        public void Print(string name)
        {
            //显示传入的值
            Console.WriteLine("输入值为：" + name);
        }
        //不属于方法重载
        //下面方法会出现编译错误
        public int Print(string name)
        {
            //显示传入的值
            Console.WriteLine("输入值为：" + name);
            return 1;
        }
        //重载 参数类型不同
        public void Print(int age)
        {
            Console.WriteLine("输入值为：" + age);
        }
        //重载 参数个数不同
        public void Print(string name, int age)
        {
            Console.WriteLine("输入值为：Name=" + name + ";Age=" + age);
        }
    }

**PS:如果两个方法只有返回值类型不同，这样的方法不能成为方法重载。**

## 4.3.4 构造函数 ##
构造函数主要用户创建类的实例对象，当调用构造函数创建一个对象时，构造函数会为对象分配内存空间，并初始化类的成员。构造函数分为实例构造函数和静态构造函数。

### 1. 实例构造函数
实例构造函数用于创建和初始化类的实例， 使用new操作符创建对象的过程，就是调用实例构造函数，来初始化类中所有实例成员。

	构造函数特点：
	1. 构造函数可以进行方法重载。
	2. 如果没有显示的指定构造函数，编译器会自动生成一个函数体为空的默认无参构造函数。
	3. 构造函数可以指定访问级别，即可以使用public，protected,private修饰符来修饰。
	4. 构造函数必须与类同名
	5. 构造函数不能有返回值类型

### 2. 静态构造函数
静态构造函数用于初始化类中的静态成员，在创建第一个实例或引用任何静态成员之前，CLR都将自动的调用静态构造函数。

    public class Person
    {
        private static string name;
        private string desc;
        //静态构造函数无法使用修饰符
        //静态构造函数只能初始化静态变量
        static Person()
        {
            name = "hello";
			//此处无法初始化 desc变量
        }
    }
	
    静态构造函数特点
	1. 静态构造函数无法使用修饰符
	2. 静态构造函数不能带有任何参数
	3. 静态构造函数只会执行一次
	4. 不能直接调用静态构造函数

>CLR Via C# 中解释：
>
>**静态构造函数是线程安全的。**
> 多个线程可能同时执行相同的方法，CLR希望取保在每个APPDomain中，一个类型构造器只执行一次。为了确保这一点，在调用类型构造器时，调用线程要获取一个互斥线程同步锁。这样一来，如果多个线程试图同时调用某个类型的静态构造函数，只有一个线程才可以获得锁，其他线程会被阻塞(blocked)。第一个线程会执行静态构造函数中代码，当第一个线程离开构造器后，正在等待的线程将被唤醒，然后发现构造器的代码已经执行过。因此这些线程不会再次执行代码，将直接从构造器方法返回。如果再次调用这样的一个方法，CLR知道静态构造函数已经执行过，从而确保构造器不被再次调用。
	
## 4.3.5 析构函数 ##
析构函数用于在**类销毁之前释放实例所有的托管和非托管资源**。C#应用程序所创建的大多数对象，可以依靠.NET Framework 的垃圾回收器(GC)来隐式的执行内存管理工作，但是若创建了非托管资源对象，在应用程序使用完这些非托管对象后，垃圾回收器将运行对象的析构函数(Finalize方法)来释放这些资源。

    public class Person
    {
		//析构函数
        ~Person()
        {
            Console.WriteLine("析构函数被调用");
        }
    }
该函数隐式的调用了Object的Finalize方法：

		protected override void Finalize()
        {
            try
            {
                Console.WriteLine("析构函数被调用");
            }
            finally
            {
                //调用Object.Finalize
            }
        }

**PS：编译器不推荐重写Finalize方法，而是提供一个析构函数，析构函数有垃圾回收器自动调用。**

## 4.3.6 索引器 ##
索引器将简化对类中数组成员的访问。索引器的定义如下：
![](http://i.imgur.com/qlouqzy.png)

    public class Person
    {
        private int[] intarray = new int[10];
        //索引起定义
        public int this[int index]
        {
            get
            {
                return intarray[index];
            }
            set
            {
                intarray[index] = value;
            }
        }
    }
	//使用索引器
    Person person = new Person();
    person[0] = 1;
    person[1] = 2;
    Console.WriteLine(person[1]);