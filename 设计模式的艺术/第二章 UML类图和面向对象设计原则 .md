## 第二章 UML类图和面向对象设计原则 ##


### 2.4 面向对象设计原则 ###

面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的重用，另一方面要确保系统能够易于扩展和修改，具有较好的灵活性。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出指导性原则。面向对象设计原则也是用于评价一个设计模式的使用效果的重要指标之一。

常见的7种面向对象设计原则

![面向对象设计原则](http://i.imgur.com/4xln1Ga.png)


### 2.5 单一职责原则 ###

单一职责原则是最简单的面向对象设计原则，**它用于控制类的粒度大小**。

单一职责原则(Single Responsibility Principle,SRP):一个类只负责一个功能领域中的相应职责。就一个类而言，应该只有一个引起它变化的原因。

单一职责原则的核心思想：一个类不能太"累"，在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变，则可将它们封装在同一个类中。

单一职责原则是实现高内聚低耦合的直到方针。

### 2.6 开闭原则 ###

开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。

开闭原则(Open-Closed Principle,OCP):一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

为了满足开闭原则，需要对系统进行抽象化设计，**抽象化**是开闭原则的关键。在面向对象语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中，都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无需对抽象层进行任何的改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

### 2.7 里氏代换原则 ###

里氏代换原则(Lickov Substitution Principle,LSP):所有引用基类(父类)的地方必须能透明地使用其子类的对象。


里氏代换原则表明：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中进行使用**基类类型来对对象进行定义，而在运行时再确定其子类类型，用于子类对象来替换父类对象。**

运用里氏代换原则时，应该将**父类设计为抽象类或接口**，让子类继承父类或实现父类接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，可以很方便进行系统扩展，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。

### 2.8 依赖倒置原则 ###

依赖倒置原则(Dependency Inversion Principle,DIP):抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程而不是针对实现编程。

依赖倒置原则要求你在程序代码中传递参数时或在关联关系中，尽量引用高层次的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要使用具体类来做这些事情。为了确保该原则应用，一个具体类应当只是想接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到子类中增加的方法。

在实现依赖倒置原则时，需要针对抽象层编程，而将具体类的对象通过**依赖注入(Dependency Injection,DI)**的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入锁依赖的对象。

常用的注入方式有3中：构造注入，设置注入(Setter注入)和接口注入。
- 构造注入：通过构造函数传入具体类型的对象。
- 设值注入：通过Setter方法来传入具体类的对象。
- 接口注入：通过实现在接口中声明的业务方法来传入具体类的对象。


### 2.9接口隔离原则 ###

接口隔离原则(InterfaceSergregation Principle,ISP):使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖于那些它不需要的接口。

接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需直到与之相关的方法即可。每一个接口应该承担一种相对独立的角色。
- 当把接口理解成一个类型所提供的所有方法特征集合时，这是一种逻辑上的概念，接口的划分直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特点的一个接口，此时这个原则可叫做“角色隔离原则”。
- 如果把接口理解成狭义的语言的接口，那么ISP表达的意思是接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独接口。而不要提供大的接口。


### 2.10 合成复用原则 ###

合成复用原则又称为 组合/聚合复用原则。

合成复用原则(Composite Reuse Principle,CRP)：尽量使用对象组合，而不是继承来达到复用的目的。

合成复用原则就是在一个新的对象里通过关联关系(组合关系和聚合关系)来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时，要尽量使用组合/聚合关系，少用继承。

通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。

由于组合或聚合关系可以将已有对象纳入到新对象总，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用称为“黑箱”复用。相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要偶选择性地调用成员对象的操作。


### 2.11 迪米特法则 ###

迪米特法则(Law of Demeter,LoD):一个软件实体应当尽可能少地与其他实体发生相互作用。

如果一个系统负荷迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。这是对软件实体之间通信的限制。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则中，对于一个对象，其”朋友“包括以下几类：
- 当前对象本身(this)
- 以参数形式传入到当前对象方法中对象
- 当前对象的成员对象
- 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友
- 当前对象所创建的对象

迪米特法则要求在设计系统时，应该尽量减少对象之间的交互。如果两个对象之间不必彼此之间通信，那么这两个对象就不应该发生任何直接的相互作用；如果其中一个对象需要调用另外一个对象的方法，可以通过第三者转发这个调用。
